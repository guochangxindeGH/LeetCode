
/**
 * 309. 买卖股票的最佳时机含冷冻期
 * 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
示例 2:

输入: prices = [1]
输出: 0
*/


/**
 * 本题包含四种状态：

状态一：持有股票。
状态二：不持有股票： 之前(早于昨天)就卖了，所以今天不处于冷冻期。
状态三：不持有股票：昨天卖的，所以今天处于冷冻期。
状态四：不持有股票：今天卖。
再来分析一下递推公式：

持有股票：①早就有了：dp[i-1][0]  ②今天刚买：昨天可能是状态二或者状态三，不可能是状态四，因为今天可以买股票，所以不处于冷冻期，所以不可能是昨天卖股票。即：dp[i-1][1]-prices[i] 或者 dp[i-1][3]-prices[i] 。 
不持有股票（之前就卖了，今天不处于冷冻期）：①昨天的之前就已经卖了，即dp[i-1][1]。 ②昨天的昨天卖的，即昨天处于冷冻期，今天不处于冷冻期，即dp[i-1][3]。
不持有股票（昨天卖，今天处于冷冻期）：已经知道是昨天卖的了，即dp[i-1][2]。
不持有股票（今天卖）： 没什么好说的，当前金额 = 昨天持有股票的钱+今天股票的股价，即dp[i-1][0] + prices[i]
*/
var maxProfit1 = function(prices) {
  const n = prices.length;
  let res = Array(n).fill(null).map(() => [0, 0, 0, 0]);
  res[0][0] = -prices[0]
  res[0][1] = 0
  res[0][2] = 0
  res[0][3] = 0

  for(let i = 1; i < n; i ++) {
    res[i][0] = Math.max(res[i - 1][0], Math.max(res[i - 1][1] - prices[i], res[i - 1][2] - prices[i]))
    res[i][1] = Math.max(res[i - 1][1], res[i - 1][2])
    res[i][2] = Math.max(res[i - 1][3])
    res[i][3] = Math.max(res[i - 1][0] + prices[i])
  }
  return Math.max(res[n - 1][1], res[n - 1][2], res[n - 1][3])
}
console.log(maxProfit1([1,2,3,0,2]))